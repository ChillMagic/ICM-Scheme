; ICM on Scheme
; library.ss
; Author : Chill

(load "basic.ss")

(library (Number)
         (export is? + - * / =?)
         (import
           (except (rnrs) + - * / =)
           (prefix (rnrs) rnrs.))
         (define is? number?)
         (define + rnrs.+)
         (define - rnrs.-)
         (define * rnrs.*)
         (define / rnrs./)
         (define =? rnrs.=))

(library (String)
         (export is? + =? ->Symbol)
         (import (except (rnrs) +))
         (define is? string?)
         (define + string-append)
         (define =? string=?)
         (define ->Symbol string->symbol))

(library (Symbol)
         (export is? =? ->String)
         (import (rnrs))
         (define is? symbol?)
         (define =? symbol=?)
         (define ->String symbol->string))

(library (List)
         (export is? make + get empty? reverse push-back push-front pop-front)
         (import
           (except (rnrs) + length)
           (prefix (rnrs) rnrs.))
         (define is? list?)
         (define make list)
         (define + append)
         (define length rnrs.length)
         (define get list-ref)
         (define empty? null?)
         (define (push-back lst elt) (+ lst (list elt)))
         (define (push-front lst elt) (+ (list elt) lst))
         (define (pop-front lst) (cdr lst)))

(library (Vector)
         (export new make is? length get set)
         (import (except (rnrs) + length))
         (define new make-vector)
         (define make vector)
         (define is? vector?)
         (define length vector-length)
         (define get vector-ref)
         (define set vector-set!))

(library (HashTable)
         (export new is? size entries keys values insert! get set get! for-each)
         (import
           (except (rnrs) values for-each)
           (prefix (Vector) Vector.))
         (define new make-eq-hashtable)
         (define is? hashtable?)
         (define size hashtable-size)
         (define keys hashtable-keys)
         (define (values hashtable) (let-values (((k v) (entries hashtable))) v))
         (define entries hashtable-entries)
         (define insert! hashtable-set!)
         (define-syntax get
           (syntax-rules ()
             ((_ hashtable key)   (hashtable-ref hashtable key `nil))
             ((_ hashtable key expr)
               (let ((val (hashtable-ref hashtable key `nil)))
                 (if (and (symbol? val) (symbol=? val `nil))
                   expr
                   val)))))
         (define (set hashtable key obj)
           (insert! hashtable key obj) obj)
         (define (get! hashtable type default)
           (get hashtable type
             (set hashtable type (default))))
         (define (for-each hashtable func)
           (let ((size (size hashtable))
                 (keys (keys hashtable))
                 (vals (values hashtable)))
             (let loop ((i 0))
               (if (not (= i size))
                 (begin
                   (func (Vector.get keys i) (Vector.get vals i))
                   (loop (+ i 1)))))))
                   )

(library (Output)
         (export p print println p-base)
         (import (rnrs) (Basic)
           (prefix (HashTable) HashTable.))
   (define (print . x)
     (loop-do display x))
   (define (println . x)
     (apply print x) (newline) x)
   (define (p . x)
     (loop-do p-base x) (newline) `nil)

   (define (p-base e)
     (cond ((number? e) (print e))
           ((string? e) (print #\" e #\"))
           ((list?   e) (print "[") (ps-base e) (print "]"))
           ((symbol? e) (print ":" e))
           ((char? e)   (print "'" e "'"))
           ((hashtable? e) (p-hashtable e))
           (else (print e))))
   (define (p-hashtable hashtable)
     (print "{")
     (HashTable.for-each hashtable
       (lambda (k v)
         (print " ")
         (p-base k)
         (print " => ")
         (p-base v)
         (print " ")))
     (print "}"))
   (define (ps-base args)
     (let ((func p-base))
       (if (not (null? args))
         (let loop ((lst args))
           (if (null? (cdr lst))
             (func (car lst))
             (begin
               (func (car lst))
               (print " ")
               (loop (cdr lst))))))))

)

(library (Convert)
         (export -> !->)
         (import (rnrs) (Basic)
           (prefix (HashTable) HashTable.)
           (prefix (Output) Output.))

         (define (!-> table t1 t2 f)
           (HashTable.set (HashTable.get! table t1 HashTable.new) t2 f))

         (define (-> table t1 t2)
           (HashTable.get
             (HashTable.get! table t1 HashTable.new)
             t2
             (lambda (v) (Output.println "Error in function " (list `-> t1 t2) ".")
                         `nil))))
