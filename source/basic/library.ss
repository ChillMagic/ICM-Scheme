; ICM on Scheme
; library.ss
; Author : Chill

(library (Number)
         (export is? + - * / =?)
         (import
           (except (rnrs) + - * / =)
           (prefix (rnrs) rnrs.))
         (define is? number?)
         (define + rnrs.+)
         (define - rnrs.-)
         (define * rnrs.*)
         (define / rnrs./)
         (define =? rnrs.=))

(library (String)
         (export is? + =? ->Symbol)
         (import (except (rnrs) +))
         (define is? string?)
         (define + string-append)
         (define =? string=?)
         (define ->Symbol string->symbol))

(library (Symbol)
         (export is? =? ->String)
         (import (rnrs))
         (define is? symbol?)
         (define =? symbol=?)
         (define ->String symbol->string))

(library (List)
         (export is? make + get empty? reverse push-back push-front pop-front for-each for-each-with-inter)
         (import
           (except (rnrs) + length for-each)
           (prefix (rnrs) rnrs.))
         (define is? list?)
         (define make list)
         (define + append)
         (define length rnrs.length)
         (define get list-ref)
         (define empty? null?)
         (define (push-back lst elt) (+ lst (list elt)))
         (define (push-front lst elt) (+ (list elt) lst))
         (define (pop-front lst) (cdr lst))
         (define (for-each lst func) (rnrs.for-each func lst))
         (define (for-each-with-inter lst elt-func int-func)
           (if (not (null? lst))
             (let loop ((lst lst))
               (if (null? (cdr lst))
                 (elt-func (car lst))
                 (begin
                   (elt-func (car lst))
                   (int-func)
                   (loop (cdr lst))))))))

(library (Vector)
         (export new make is? length get set for-each for-each-with-inter symbol-sort)
         (import (except (rnrs) + length for-each) (prefix (rnrs) rnrs.))
         (define new make-vector)
         (define make vector)
         (define is? vector?)
         (define length vector-length)
         (define get vector-ref)
         (define set vector-set!)
         (define (for-each vector func)
           (let ((size (length vector)))
             (let loop ((i 0))
               (when (not (= i size))
                     (func (get vector i))
                     (loop (rnrs.+ i 1))))))
         (define (for-each-with-inter vector elt-func int-func)
           (let ((size (length vector)))
             (if (not (= size 0))
               (let loop ((i 0))
                 (elt-func (get vector i))
                 (when (not (= i (- size 1)))
                       (int-func)
                       (loop (rnrs.+ i 1)))))))
         (define (symbol-sort vector)
           (vector-sort (lambda (a b) (string<? (symbol->string a) (symbol->string b))) vector)))

(library (HashTable)
         (export new is? size entries keys values insert! get set get! for-each for-each-with-inter for-sort-each)
         (import
           (except (rnrs) values for-each)
           (prefix (Vector) Vector.))
         (define new make-eq-hashtable)
         (define is? hashtable?)
         (define size hashtable-size)
         (define keys hashtable-keys)
         (define (values hashtable) (let-values (((k v) (entries hashtable))) v))
         (define entries hashtable-entries)
         (define insert! hashtable-set!)
         (define-syntax get
           (syntax-rules ()
             ((_ hashtable key)   (hashtable-ref hashtable key `nil))
             ((_ hashtable key expr)
               (let ((val (hashtable-ref hashtable key `nil)))
                 (if (and (symbol? val) (symbol=? val `nil)) expr val)))))
         (define (set hashtable key obj)
           (insert! hashtable key obj) obj)
         (define (get! hashtable type default)
           (get hashtable type
             (set hashtable type (default))))
         (define (for-each hashtable func)
           (let ((size (size hashtable))
                 (keys (keys hashtable))
                 (vals (values hashtable)))
             (let loop ((i 0))
               (when (not (= i size))
                     (func (Vector.get keys i) (Vector.get vals i))
                     (loop (+ i 1))))))
         (define (for-each-with-inter hashtable elt-func int-func)
           (let ((size (size hashtable))
                 (keys (keys hashtable))
                 (vals (values hashtable)))
             (if (not (= size 0))
               (let loop ((i 0))
                 (elt-func (Vector.get keys i) (Vector.get vals i))
                 (when (not (= i (- size 1)))
                       (int-func)
                       (loop (+ i 1)))))))
         (define (for-sort-each hashtable sort-keys-func func)
           (Vector.for-each
             (sort-keys-func (hashtable-keys hashtable))
             (lambda (k) (func k (hashtable-ref hashtable k '()))))))

(library (ToStringFormat)
         (export to-string to-pformat type display-to-string SystemToStringFormatTable)
         (import (rnrs)
           (prefix (Vector) Vector.)
           (prefix (HashTable) HashTable.))

         (define SystemToStringFormatTable (HashTable.new))
         (define (type e)
           (cond ((boolean? e)    'boolean)
                 ((symbol? e)     'symbol)
                 ((number? e)     'number)
                 ((char? e)       'char)
                 ((string? e)     'string)
                 ((vector? e)     'vector)
                 ((procedure? e)  'procedure)
                 ((list? e)       'list)
                 ((eof-object? e) 'eof)
                 ((hashtable? e)  'hashtable)
                 (else            'unkonwn)))
         (define (display-to-string v)
           (let-values (((port result) (open-string-output-port)))
             (display v port)
             (result)))
         (define (to-pformat e)
           ((Vector.get (HashTable.get SystemToStringFormatTable (type e) (unfind e)) 1) e))
         (define (to-string e)
           ((Vector.get (HashTable.get SystemToStringFormatTable (type e) (unfind e)) 0) e))
         (define (unfind e)
           (display "Unfind ")
           (write e)
           (display ".\n")))

(library (Output)
         (export p print println)
         (import (rnrs)
           (prefix (List) List.)
           (prefix (HashTable) HashTable.)
           (prefix (ToStringFormat) ToStringFormat.))
         (define (print . x)
           (for-each print-base x) x)
         (define (println . x)
           (apply print x) (newline) x)
         (define (p . x)
           (for-each p-base x) (newline) `nil)
         (define (print-base e)
           (display (ToStringFormat.to-string e)))
         (define (p-base e)
           (display (ToStringFormat.to-pformat e))))

(library (Convert)
         (export -> !->)
         (import (rnrs)
           (prefix (HashTable) HashTable.)
           (prefix (Output) Output.))

         (define (!-> table t1 t2 f)
           (HashTable.set (HashTable.get! table t1 HashTable.new) t2 f))

         (define (-> table t1 t2)
           (HashTable.get
             (HashTable.get! table t1 HashTable.new)
             t2
             (lambda (v) (Output.println "Error in function " (list `-> t1 t2) ".")
                         `nil))))
